{"version":3,"file":"Singleplayer.stories-32e2a89f.js","sources":["../../node_modules/.pnpm/minecraft-assets@1.12.2/node_modules/minecraft-assets/minecraft-assets/data/1.10/gui/presets/isles.png","../../node_modules/.pnpm/filesize@10.0.12/node_modules/filesize/dist/filesize.esm.js","../../node_modules/.pnpm/dequal@1.0.0/node_modules/dequal/dist/dequal.mjs","../../node_modules/.pnpm/use-deep-compare@1.1.0_react@18.2.0/node_modules/use-deep-compare/dist-web/index.js","../../node_modules/.pnpm/use-typed-event-listener@4.0.2_react@18.2.0_typescript@5.2.2/node_modules/use-typed-event-listener/dist/index.mjs","../../node_modules/.pnpm/tabbable@6.2.0/node_modules/tabbable/dist/index.esm.js","../../src/react/Input.tsx","../../src/react/Singleplayer.tsx"],"sourcesContent":["export default \"__VITE_ASSET__cdcdf3a0__\"","/**\n * filesize\n *\n * @copyright 2023 Jason Mulligan <jason.mulligan@avoidwork.com>\n * @license BSD-3-Clause\n * @version 10.0.12\n */\nconst ARRAY = \"array\";\r\nconst BIT = \"bit\";\r\nconst BITS = \"bits\";\r\nconst BYTE = \"byte\";\r\nconst BYTES = \"bytes\";\r\nconst EMPTY = \"\";\r\nconst EXPONENT = \"exponent\";\r\nconst FUNCTION = \"function\";\r\nconst IEC = \"iec\";\r\nconst INVALID_NUMBER = \"Invalid number\";\r\nconst INVALID_ROUND = \"Invalid rounding method\";\r\nconst JEDEC = \"jedec\";\r\nconst OBJECT = \"object\";\r\nconst PERIOD = \".\";\r\nconst ROUND = \"round\";\r\nconst S = \"s\";\r\nconst SI_KBIT = \"kbit\";\r\nconst SI_KBYTE = \"kB\";\r\nconst SPACE = \" \";\r\nconst STRING = \"string\";\r\nconst ZERO = \"0\";\r\nconst STRINGS = {\r\n\tsymbol: {\r\n\t\tiec: {\r\n\t\t\tbits: [\"bit\", \"Kibit\", \"Mibit\", \"Gibit\", \"Tibit\", \"Pibit\", \"Eibit\", \"Zibit\", \"Yibit\"],\r\n\t\t\tbytes: [\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"]\r\n\t\t},\r\n\t\tjedec: {\r\n\t\t\tbits: [\"bit\", \"Kbit\", \"Mbit\", \"Gbit\", \"Tbit\", \"Pbit\", \"Ebit\", \"Zbit\", \"Ybit\"],\r\n\t\t\tbytes: [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"]\r\n\t\t}\r\n\t},\r\n\tfullform: {\r\n\t\tiec: [\"\", \"kibi\", \"mebi\", \"gibi\", \"tebi\", \"pebi\", \"exbi\", \"zebi\", \"yobi\"],\r\n\t\tjedec: [\"\", \"kilo\", \"mega\", \"giga\", \"tera\", \"peta\", \"exa\", \"zetta\", \"yotta\"]\r\n\t}\r\n};function filesize (arg, {\r\n\tbits = false,\r\n\tpad = false,\r\n\tbase = -1,\r\n\tround = 2,\r\n\tlocale = EMPTY,\r\n\tlocaleOptions = {},\r\n\tseparator = EMPTY,\r\n\tspacer = SPACE,\r\n\tsymbols = {},\r\n\tstandard = EMPTY,\r\n\toutput = STRING,\r\n\tfullform = false,\r\n\tfullforms = [],\r\n\texponent = -1,\r\n\troundingMethod = ROUND,\r\n\tprecision = 0\r\n} = {}) {\r\n\tlet e = exponent,\r\n\t\tnum = Number(arg),\r\n\t\tresult = [],\r\n\t\tval = 0,\r\n\t\tu = EMPTY;\r\n\r\n\t// Sync base & standard\r\n\tif (base === -1 && standard.length === 0) {\r\n\t\tbase = 10;\r\n\t\tstandard = JEDEC;\r\n\t} else if (base === -1 && standard.length > 0) {\r\n\t\tstandard = standard === IEC ? IEC : JEDEC;\r\n\t\tbase = standard === IEC ? 2 : 10;\r\n\t} else {\r\n\t\tbase = base === 2 ? 2 : 10;\r\n\t\tstandard = base === 10 ? JEDEC : standard === JEDEC ? JEDEC : IEC;\r\n\t}\r\n\r\n\tconst ceil = base === 10 ? 1000 : 1024,\r\n\t\tfull = fullform === true,\r\n\t\tneg = num < 0,\r\n\t\troundingFunc = Math[roundingMethod];\r\n\r\n\tif (typeof arg !== \"bigint\" && isNaN(arg)) {\r\n\t\tthrow new TypeError(INVALID_NUMBER);\r\n\t}\r\n\r\n\tif (typeof roundingFunc !== FUNCTION) {\r\n\t\tthrow new TypeError(INVALID_ROUND);\r\n\t}\r\n\r\n\t// Flipping a negative number to determine the size\r\n\tif (neg) {\r\n\t\tnum = -num;\r\n\t}\r\n\r\n\t// Determining the exponent\r\n\tif (e === -1 || isNaN(e)) {\r\n\t\te = Math.floor(Math.log(num) / Math.log(ceil));\r\n\r\n\t\tif (e < 0) {\r\n\t\t\te = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// Exceeding supported length, time to reduce & multiply\r\n\tif (e > 8) {\r\n\t\tif (precision > 0) {\r\n\t\t\tprecision += 8 - e;\r\n\t\t}\r\n\r\n\t\te = 8;\r\n\t}\r\n\r\n\tif (output === EXPONENT) {\r\n\t\treturn e;\r\n\t}\r\n\r\n\t// Zero is now a special case because bytes divide by 1\r\n\tif (num === 0) {\r\n\t\tresult[0] = 0;\r\n\t\tu = result[1] = STRINGS.symbol[standard][bits ? BITS : BYTES][e];\r\n\t} else {\r\n\t\tval = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1000, e));\r\n\r\n\t\tif (bits) {\r\n\t\t\tval = val * 8;\r\n\r\n\t\t\tif (val >= ceil && e < 8) {\r\n\t\t\t\tval = val / ceil;\r\n\t\t\t\te++;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst p = Math.pow(10, e > 0 ? round : 0);\r\n\t\tresult[0] = roundingFunc(val * p) / p;\r\n\r\n\t\tif (result[0] === ceil && e < 8 && exponent === -1) {\r\n\t\t\tresult[0] = 1;\r\n\t\t\te++;\r\n\t\t}\r\n\r\n\t\tu = result[1] = base === 10 && e === 1 ? bits ? SI_KBIT : SI_KBYTE : STRINGS.symbol[standard][bits ? BITS : BYTES][e];\r\n\t}\r\n\r\n\t// Decorating a 'diff'\r\n\tif (neg) {\r\n\t\tresult[0] = -result[0];\r\n\t}\r\n\r\n\t// Setting optional precision\r\n\tif (precision > 0) {\r\n\t\tresult[0] = result[0].toPrecision(precision);\r\n\t}\r\n\r\n\t// Applying custom symbol\r\n\tresult[1] = symbols[result[1]] || result[1];\r\n\r\n\tif (locale === true) {\r\n\t\tresult[0] = result[0].toLocaleString();\r\n\t} else if (locale.length > 0) {\r\n\t\tresult[0] = result[0].toLocaleString(locale, localeOptions);\r\n\t} else if (separator.length > 0) {\r\n\t\tresult[0] = result[0].toString().replace(PERIOD, separator);\r\n\t}\r\n\r\n\tif (pad && Number.isInteger(result[0]) === false && round > 0) {\r\n\t\tconst x = separator || PERIOD,\r\n\t\t\ttmp = result[0].toString().split(x),\r\n\t\t\ts = tmp[1] || EMPTY,\r\n\t\t\tl = s.length,\r\n\t\t\tn = round - l;\r\n\r\n\t\tresult[0] = `${tmp[0]}${x}${s.padEnd(l + n, ZERO)}`;\r\n\t}\r\n\r\n\tif (full) {\r\n\t\tresult[1] = fullforms[e] ? fullforms[e] : STRINGS.fullform[standard][e] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY : S);\r\n\t}\r\n\r\n\t// Returning Array, Object, or String (default)\r\n\treturn output === ARRAY ? result : output === OBJECT ? {\r\n\t\tvalue: result[0],\r\n\t\tsymbol: result[1],\r\n\t\texponent: e,\r\n\t\tunit: u\r\n\t} : result.join(spacer);\r\n}\r\n\r\n// Partial application for functional programming\r\nfunction partial ({\r\n\tbits = false,\r\n\tpad = false,\r\n\tbase = -1,\r\n\tround = 2,\r\n\tlocale = EMPTY,\r\n\tlocaleOptions = {},\r\n\tseparator = EMPTY,\r\n\tspacer = SPACE,\r\n\tsymbols = {},\r\n\tstandard = EMPTY,\r\n\toutput = STRING,\r\n\tfullform = false,\r\n\tfullforms = [],\r\n\texponent = -1,\r\n\troundingMethod = ROUND,\r\n\tprecision = 0\r\n} = {}) {\r\n\treturn arg => filesize(arg, {\r\n\t\tbits,\r\n\t\tpad,\r\n\t\tbase,\r\n\t\tround,\r\n\t\tlocale,\r\n\t\tlocaleOptions,\r\n\t\tseparator,\r\n\t\tspacer,\r\n\t\tsymbols,\r\n\t\tstandard,\r\n\t\toutput,\r\n\t\tfullform,\r\n\t\tfullforms,\r\n\t\texponent,\r\n\t\troundingMethod,\r\n\t\tprecision\r\n\t});\r\n}export{filesize,partial};","export default function dequal(foo, bar) {\n\tvar ctor, len;\n\tif (foo === bar) return true;\n\tif (foo && bar && (ctor=foo.constructor) === bar.constructor) {\n\t\tif (ctor === Date) return foo.getTime() === bar.getTime();\n\t\tif (ctor === RegExp) return foo.toString() === bar.toString();\n\t\tif (ctor === Array && (len=foo.length) === bar.length) {\n\t\t\twhile (len-- && dequal(foo[len], bar[len]));\n\t\t\treturn len === -1;\n\t\t}\n\t\tif (ctor === Object) {\n\t\t\tif (Object.keys(foo).length !== Object.keys(bar).length) return false;\n\t\t\tfor (len in foo) if (!(len in bar) || !dequal(foo[len], bar[len])) return false;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn foo !== foo && bar !== bar;\n}\n","import React from 'react';\nimport deepEqual from 'dequal';\n\nfunction checkDeps(deps, name) {\n  const reactHookName = `React.${name.replace(/DeepCompare/, \"\")}`;\n\n  if (!deps || deps.length === 0) {\n    throw new Error(`${name} should not be used with no dependencies. Use ${reactHookName} instead.`);\n  }\n}\nfunction useDeepCompareMemoize(value) {\n  const ref = React.useRef([]);\n\n  if (!deepEqual(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n\n/**\n * `useDeepCompareEffect` will return a memoized version of the callback that\n * only changes if one of the `deps` has changed.\n *\n * Usage note: only use this if `deps` are objects or arrays that contain\n * objects. Otherwise you should just use React.useEffect.\n *\n */\n\nfunction useDeepCompareCallback(callback, dependencies) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkDeps(dependencies, 'useDeepCompareCallback');\n  }\n\n  return React.useCallback(callback, useDeepCompareMemoize(dependencies));\n}\n\n/**\n * `useDeepCompareEffect` Accepts a function that contains imperative, possibly\n * effectful code.\n *\n * @param effect Imperative function that can return a cleanup function\n * @param deps If present, effect will only activate if the values in the list\n * change.\n *\n * Usage note: only use this if `deps` are objects or arrays that contain\n * objects. Otherwise you should just use React.useEffect.\n *\n */\n\nfunction useDeepCompareEffect(effect, dependencies) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkDeps(dependencies, 'useDeepCompareEffect');\n  }\n\n  React.useEffect(effect, useDeepCompareMemoize(dependencies));\n}\n\n/**\n * `useDeepCompareMemo` will only recompute the memoized value when one of the\n * `deps` has changed.\n *\n * Usage note: only use this if `deps` are objects or arrays that contain\n * objects. Otherwise you should just use React.useMemo.\n *\n */\n\nfunction useDeepCompareMemo(factory, dependencies) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkDeps(dependencies, 'useDeepCompareMemo');\n  }\n\n  return React.useMemo(factory, useDeepCompareMemoize(dependencies));\n}\n\nexport { useDeepCompareCallback, useDeepCompareEffect, useDeepCompareMemo };\n//# sourceMappingURL=index.js.map\n","import*as e from\"react\";import{useDeepCompareMemo as r}from\"use-deep-compare\";function t(t,n,o,c){const s=e.useRef(o);s.current=o;const u=r((()=>c),[c]);e.useEffect((()=>{if(!t)return;const e=e=>s.current.call(t,e);return t.addEventListener(n,e,u),()=>{t.removeEventListener(n,e,u)}}),[t,n,u])}export{t as default};\n//# sourceMappingURL=index.mjs.map\n","/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","import React, { useEffect, useRef } from 'react'\nimport styles from './input.module.css'\nimport { useUsingTouch } from './utils'\n\ninterface Props extends React.ComponentProps<'input'> {\n  autoFocus?: boolean\n}\n\nexport default ({ autoFocus, ...inputProps }: Props) => {\n  const ref = useRef<HTMLInputElement>(null!)\n  const isTouch = useUsingTouch()\n\n  useEffect(() => {\n    if (!autoFocus || isTouch) return // Don't make screen keyboard popup on mobile\n    ref.current.focus()\n  }, [])\n\n  return <div className={styles.container}>\n    <input ref={ref} className={styles.input} autoComplete='off' autoCapitalize='off' autoCorrect='off' autoSave='off' spellCheck='false' {...inputProps} />\n  </div>\n}\n","import classNames from 'classnames'\nimport { useMemo, useRef, useState } from 'react'\n\n// todo optimize size\nimport missingWorldPreview from 'minecraft-assets/minecraft-assets/data/1.10/gui/presets/isles.png'\nimport { filesize } from 'filesize'\nimport useTypedEventListener from 'use-typed-event-listener'\nimport { focusable } from 'tabbable'\nimport styles from './singleplayer.module.css'\nimport Input from './Input'\nimport Button from './Button'\n\nexport interface WorldProps {\n  name: string\n  title: string\n  size?: number\n  lastPlayed?: number\n  isFocused?: boolean\n  onFocus?: (name: string) => void\n  detail?: string\n  onInteraction?(interaction: 'enter' | 'space')\n}\nconst World = ({ name, isFocused, title, lastPlayed, size, detail = '', onFocus, onInteraction }: WorldProps) => {\n  const timeRelativeFormatted = useMemo(() => {\n    if (!lastPlayed) return\n    const formatter = new Intl.RelativeTimeFormat('en', { numeric: 'auto' })\n    const diff = Date.now() - lastPlayed\n    const minutes = Math.floor(diff / 1000 / 60)\n    const hours = Math.floor(minutes / 60)\n    const days = Math.floor(hours / 24)\n    // const weeks = Math.floor(days / 7)\n    // const months = Math.floor(days / 30)\n    if (days > 0) return formatter.format(-days, 'day')\n    if (hours > 0) return formatter.format(-hours, 'hour')\n    return formatter.format(-minutes, 'minute')\n  }, [lastPlayed])\n  const sizeFormatted = useMemo(() => {\n    if (!size) return\n    return filesize(size)\n  }, [size])\n\n  return <div className={classNames(styles.world_root, isFocused ? styles.world_focused : undefined)} tabIndex={0} onFocus={() => onFocus?.(name)} onKeyDown={(e) => {\n    if (e.code === 'Enter' || e.code === 'Space') {\n      e.preventDefault()\n      onInteraction?.(e.code === 'Enter' ? 'enter' : 'space')\n    }\n  }} onDoubleClick={() => onInteraction?.('enter')}>\n    <img className={styles.world_image} src={missingWorldPreview} />\n    <div className={styles.world_info}>\n      <div className={styles.world_title} title='level.dat world name'>{title}</div>\n      <div className='muted'>{timeRelativeFormatted} {detail.slice(-30)}</div>\n      <div className='muted'>{sizeFormatted}</div>\n    </div>\n  </div>\n}\n\ninterface Props {\n  worldData: WorldProps[]\n  onWorldAction (action: 'load' | 'export' | 'delete' | 'edit', worldName: string): void\n  onGeneralAction (action: 'cancel' | 'create'): void\n}\n\nexport default ({ worldData, onGeneralAction, onWorldAction }: Props) => {\n  const containerRef = useRef<any>()\n  const firstButton = useRef<HTMLButtonElement>(null!)\n\n  useTypedEventListener(window, 'keydown', (e) => {\n    if (e.code === 'ArrowDown' || e.code === 'ArrowUp') {\n      e.preventDefault()\n      const dir = e.code === 'ArrowDown' ? 1 : -1\n      const elements = focusable(containerRef.current)\n      const focusedElemIndex = elements.indexOf(document.activeElement as HTMLElement)\n      if (focusedElemIndex === -1) return\n      const nextElem = elements[focusedElemIndex + dir]\n      nextElem?.focus()\n    }\n  })\n\n  const [search, setSearch] = useState('')\n  const [focusedWorld, setFocusedWorld] = useState('')\n\n  return <div ref={containerRef}>\n    <div className=\"dirt-bg\" />\n    <div className={classNames('fullscreen', styles.root)}>\n      <div style={{ display: 'flex', flexDirection: 'column' }}>\n        <span className={classNames('screen-title', styles.title)}>Select Saved World</span>\n        <Input autoFocus value={search} onChange={({ target: { value } }) => setSearch(value)} />\n      </div>\n      <div className={styles.content}>\n        {\n          worldData.filter(data => data.title.toLowerCase().includes(search.toLowerCase())).map(({ name, title, size, lastPlayed, detail }) => (\n            <World title={title} lastPlayed={lastPlayed} size={size} name={name} onFocus={setFocusedWorld} isFocused={focusedWorld === name} key={name} onInteraction={(interaction) => {\n              if (interaction === 'enter') onWorldAction('load', name)\n              else if (interaction === 'space') firstButton.current?.focus()\n            }} detail={detail} />\n          ))\n        }\n      </div>\n      <div style={{ display: 'flex', flexDirection: 'column', minWidth: 400 }}>\n        <div>\n          <Button rootRef={firstButton} disabled={!focusedWorld} onClick={() => onWorldAction('load', focusedWorld)}>LOAD WORLD</Button>\n          <Button onClick={() => onGeneralAction('create')}>Create New World</Button>\n        </div>\n        <div>\n          <Button style={{ width: 100 }} disabled={!focusedWorld} onClick={() => onWorldAction('export', focusedWorld)}>Export</Button>\n          <Button style={{ width: 100 }} disabled={!focusedWorld} onClick={() => onWorldAction('delete', focusedWorld)}>Delete</Button>\n          <Button style={{ width: 100 }} /* disabled={!focusedWorld}  */ onClick={() => onWorldAction('edit', focusedWorld)} disabled>Edit</Button>\n          <Button style={{ width: 100 }} onClick={() => onGeneralAction('cancel')}>Cancel</Button>\n        </div>\n      </div>\n    </div>\n  </div>\n}\n"],"names":["missingWorldPreview","ARRAY","BIT","BITS","BYTE","BYTES","EMPTY","EXPONENT","FUNCTION","IEC","INVALID_NUMBER","INVALID_ROUND","JEDEC","OBJECT","PERIOD","ROUND","S","SI_KBIT","SI_KBYTE","SPACE","STRING","ZERO","STRINGS","filesize","arg","bits","pad","base","round","locale","localeOptions","separator","spacer","symbols","standard","output","fullform","fullforms","exponent","roundingMethod","precision","e","num","result","val","u","ceil","full","neg","roundingFunc","p","x","tmp","s","l","n","dequal","foo","bar","ctor","len","useDeepCompareMemoize","value","ref","React","deepEqual","useDeepCompareMemo","factory","dependencies","t","o","c","e.useRef","r","e.useEffect","candidateSelectors","candidateSelector","NoElement","matches","getRootNode","element","_element$getRootNode","isInert","node","lookUp","_node$getAttribute","inertAtt","inert","getCandidates","el","includeContainer","filter","candidates","getCandidatesIteratively","elements","options","elementsToCheck","assigned","content","nestedCandidates","validCandidate","shadowRoot","validShadowRoot","_nestedCandidates","isInput","isHiddenInput","isDetailsWithSummary","child","isNodeAttached","_nodeRoot","nodeRoot","nodeRootHost","attached","_nodeRootHost","_nodeRootHost$ownerDo","_node$ownerDocument","_nodeRoot2","_nodeRootHost2","_nodeRootHost2$ownerD","isZeroArea","_node$getBoundingClie","width","height","isHidden","_ref","displayCheck","getShadowRoot","isDirectSummary","nodeUnderDetails","originalNode","parentElement","rootNode","isDisabledFromFieldset","parentNode","i","isNodeMatchingSelectorFocusable","focusable","container","Input$1","autoFocus","inputProps","useRef","isTouch","useUsingTouch","useEffect","jsx","styles","World","name","isFocused","title","lastPlayed","size","detail","onFocus","onInteraction","timeRelativeFormatted","useMemo","formatter","diff","minutes","hours","days","sizeFormatted","jsxs","classNames","Singleplayer$1","worldData","onGeneralAction","onWorldAction","containerRef","firstButton","useTypedEventListener","dir","focusedElemIndex","nextElem","search","setSearch","useState","focusedWorld","setFocusedWorld","Input","data","interaction","_a","Button"],"mappings":"gUAAA,MAAeA,GAAA,GAAA,IAAA,IAAA,qBAAA,YAAA,GAAA,EAAA,KCAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAOA,MAAMC,GAAQ,QACRC,GAAM,MACNC,EAAO,OACPC,GAAO,OACPC,EAAQ,QACRC,EAAQ,GACRC,GAAW,WACXC,GAAW,WACXC,EAAM,MACNC,GAAiB,iBACjBC,GAAgB,0BAChBC,EAAQ,QACRC,GAAS,SACTC,EAAS,IACTC,GAAQ,QACRC,GAAI,IACJC,GAAU,OACVC,GAAW,KACXC,GAAQ,IACRC,GAAS,SACTC,GAAO,IACPC,EAAU,CACf,OAAQ,CACP,IAAK,CACJ,KAAM,CAAC,MAAO,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,QAAS,OAAO,EACpF,MAAO,CAAC,IAAK,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,MAAO,KAAK,CACnE,EACD,MAAO,CACN,KAAM,CAAC,MAAO,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,MAAM,EAC5E,MAAO,CAAC,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,KAAM,IAAI,CAC3D,CACD,EACD,SAAU,CACT,IAAK,CAAC,GAAI,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,MAAM,EACxE,MAAO,CAAC,GAAI,OAAQ,OAAQ,OAAQ,OAAQ,OAAQ,MAAO,QAAS,OAAO,CAC3E,CACF,EAAE,SAASC,GAAUC,EAAK,CACzB,KAAAC,EAAO,GACP,IAAAC,EAAM,GACN,KAAAC,EAAO,GACP,MAAAC,EAAQ,EACR,OAAAC,EAASvB,EACT,cAAAwB,EAAgB,CAAE,EAClB,UAAAC,EAAYzB,EACZ,OAAA0B,EAASb,GACT,QAAAc,EAAU,CAAE,EACZ,SAAAC,EAAW5B,EACX,OAAA6B,EAASf,GACT,SAAAgB,EAAW,GACX,UAAAC,EAAY,CAAE,EACd,SAAAC,EAAW,GACX,eAAAC,EAAiBxB,GACjB,UAAAyB,EAAY,CACb,EAAI,GAAI,CACP,IAAIC,EAAIH,EACPI,EAAM,OAAOlB,CAAG,EAChBmB,EAAS,CAAE,EACXC,EAAM,EACNC,EAAIvC,EAGDqB,IAAS,IAAMO,EAAS,SAAW,GACtCP,EAAO,GACPO,EAAWtB,GACDe,IAAS,IAAMO,EAAS,OAAS,GAC3CA,EAAWA,IAAazB,EAAMA,EAAMG,EACpCe,EAAOO,IAAazB,EAAM,EAAI,KAE9BkB,EAAOA,IAAS,EAAI,EAAI,GACxBO,EAAWP,IAAS,IAAaO,IAAatB,EAArBA,EAAqCH,GAG/D,MAAMqC,EAAOnB,IAAS,GAAK,IAAO,KACjCoB,GAAOX,IAAa,GACpBY,EAAMN,EAAM,EACZO,EAAe,KAAKV,CAAc,EAEnC,GAAI,OAAOf,GAAQ,UAAY,MAAMA,CAAG,EACvC,MAAM,IAAI,UAAUd,EAAc,EAGnC,GAAI,OAAOuC,IAAiBzC,GAC3B,MAAM,IAAI,UAAUG,EAAa,EA0BlC,GAtBIqC,IACHN,EAAM,CAACA,IAIJD,IAAM,IAAM,MAAMA,CAAC,KACtBA,EAAI,KAAK,MAAM,KAAK,IAAIC,CAAG,EAAI,KAAK,IAAII,CAAI,CAAC,EAEzCL,EAAI,IACPA,EAAI,IAKFA,EAAI,IACHD,EAAY,IACfA,GAAa,EAAIC,GAGlBA,EAAI,GAGDN,IAAW5B,GACd,OAAOkC,EAIR,GAAIC,IAAQ,EACXC,EAAO,CAAC,EAAI,EACZE,EAAIF,EAAO,CAAC,EAAIrB,EAAQ,OAAOY,CAAQ,EAAET,EAAOtB,EAAOE,CAAK,EAAEoC,CAAC,MACzD,CACNG,EAAMF,GAAOf,IAAS,EAAI,KAAK,IAAI,EAAGc,EAAI,EAAE,EAAI,KAAK,IAAI,IAAMA,CAAC,GAE5DhB,IACHmB,EAAMA,EAAM,EAERA,GAAOE,GAAQL,EAAI,IACtBG,EAAMA,EAAME,EACZL,MAIF,MAAMS,EAAI,KAAK,IAAI,GAAIT,EAAI,EAAIb,EAAQ,CAAC,EACxCe,EAAO,CAAC,EAAIM,EAAaL,EAAMM,CAAC,EAAIA,EAEhCP,EAAO,CAAC,IAAMG,GAAQL,EAAI,GAAKH,IAAa,KAC/CK,EAAO,CAAC,EAAI,EACZF,KAGDI,EAAIF,EAAO,CAAC,EAAIhB,IAAS,IAAMc,IAAM,EAAIhB,EAAOR,GAAUC,GAAWI,EAAQ,OAAOY,CAAQ,EAAET,EAAOtB,EAAOE,CAAK,EAAEoC,CAAC,CACpH,CAuBD,GApBIO,IACHL,EAAO,CAAC,EAAI,CAACA,EAAO,CAAC,GAIlBH,EAAY,IACfG,EAAO,CAAC,EAAIA,EAAO,CAAC,EAAE,YAAYH,CAAS,GAI5CG,EAAO,CAAC,EAAIV,EAAQU,EAAO,CAAC,CAAC,GAAKA,EAAO,CAAC,EAEtCd,IAAW,GACdc,EAAO,CAAC,EAAIA,EAAO,CAAC,EAAE,eAAc,EAC1Bd,EAAO,OAAS,EAC1Bc,EAAO,CAAC,EAAIA,EAAO,CAAC,EAAE,eAAed,EAAQC,CAAa,EAChDC,EAAU,OAAS,IAC7BY,EAAO,CAAC,EAAIA,EAAO,CAAC,EAAE,SAAQ,EAAG,QAAQ7B,EAAQiB,CAAS,GAGvDL,GAAO,OAAO,UAAUiB,EAAO,CAAC,CAAC,IAAM,IAASf,EAAQ,EAAG,CAC9D,MAAMuB,EAAIpB,GAAajB,EACtBsC,EAAMT,EAAO,CAAC,EAAE,SAAU,EAAC,MAAMQ,CAAC,EAClCE,EAAID,EAAI,CAAC,GAAK9C,EACdgD,EAAID,EAAE,OACNE,GAAI3B,EAAQ0B,EAEbX,EAAO,CAAC,EAAI,GAAGS,EAAI,CAAC,CAAC,GAAGD,CAAC,GAAGE,EAAE,OAAOC,EAAIC,GAAGlC,EAAI,CAAC,EACjD,CAED,OAAI0B,KACHJ,EAAO,CAAC,EAAIN,EAAUI,CAAC,EAAIJ,EAAUI,CAAC,EAAInB,EAAQ,SAASY,CAAQ,EAAEO,CAAC,GAAKhB,EAAOvB,GAAME,KAASuC,EAAO,CAAC,IAAM,EAAIrC,EAAQU,KAIrHmB,IAAWlC,GAAQ0C,EAASR,IAAWtB,GAAS,CACtD,MAAO8B,EAAO,CAAC,EACf,OAAQA,EAAO,CAAC,EAChB,SAAUF,EACV,KAAMI,CACR,EAAKF,EAAO,KAAKX,CAAM,CACvB,CC5Le,SAASwB,EAAOC,EAAKC,EAAK,CACxC,IAAIC,EAAMC,EACV,GAAIH,IAAQC,EAAK,MAAO,GACxB,GAAID,GAAOC,IAAQC,EAAKF,EAAI,eAAiBC,EAAI,YAAa,CAC7D,GAAIC,IAAS,KAAM,OAAOF,EAAI,YAAcC,EAAI,UAChD,GAAIC,IAAS,OAAQ,OAAOF,EAAI,aAAeC,EAAI,WACnD,GAAIC,IAAS,QAAUC,EAAIH,EAAI,UAAYC,EAAI,OAAQ,CACtD,KAAOE,KAASJ,EAAOC,EAAIG,CAAG,EAAGF,EAAIE,CAAG,CAAC,GAAE,CAC3C,OAAOA,IAAQ,EACf,CACD,GAAID,IAAS,OAAQ,CACpB,GAAI,OAAO,KAAKF,CAAG,EAAE,SAAW,OAAO,KAAKC,CAAG,EAAE,OAAQ,MAAO,GAChE,IAAKE,KAAOH,EAAK,GAAI,EAAEG,KAAOF,IAAQ,CAACF,EAAOC,EAAIG,CAAG,EAAGF,EAAIE,CAAG,CAAC,EAAG,MAAO,GAC1E,MAAO,EACP,CACD,CACD,OAAOH,IAAQA,GAAOC,IAAQA,CAC/B,CCPA,SAASG,GAAsBC,EAAO,CACpC,MAAMC,EAAMC,GAAM,OAAO,CAAE,CAAA,EAE3B,OAAKC,EAAUH,EAAOC,EAAI,OAAO,IAC/BA,EAAI,QAAUD,GAGTC,EAAI,OACb,CAiDA,SAASG,GAAmBC,EAASC,EAAc,CAKjD,OAAOJ,GAAM,QAAQG,EAASN,GAAsBO,CAAY,CAAC,CACnE,CCzE8E,SAASC,GAAEA,EAAEd,EAAEe,EAAEC,EAAE,CAAC,MAAMlB,EAAEmB,EAAQ,OAACF,CAAC,EAAEjB,EAAE,QAAQiB,EAAE,MAAM,EAAEG,GAAG,IAAIF,EAAG,CAACA,CAAC,CAAC,EAAEG,YAAa,IAAI,CAAC,GAAG,CAACL,EAAE,OAAO,MAAM5B,EAAEA,GAAGY,EAAE,QAAQ,KAAKgB,EAAE5B,CAAC,EAAE,OAAO4B,EAAE,iBAAiBd,EAAEd,EAAE,CAAC,EAAE,IAAI,CAAC4B,EAAE,oBAAoBd,EAAEd,EAAE,CAAC,CAAC,CAAC,EAAG,CAAC4B,EAAEd,EAAE,CAAC,CAAC,CAAC,CCArS;AAAA;AAAA;AAAA,EASA,IAAIoB,GAAqB,CAAC,qBAAsB,sBAAuB,wBAAyB,uBAAwB,sBAAuB,oCAAqC,+BAAgC,+BAAgC,gEAAiE,6CAA8C,sBAAsB,EACrXC,EAAmCD,GAAmB,KAAK,GAAG,EAC9DE,GAAY,OAAO,QAAY,IAC/BC,EAAUD,GAAY,UAAY,GAAK,QAAQ,UAAU,SAAW,QAAQ,UAAU,mBAAqB,QAAQ,UAAU,sBAC7HE,EAAc,CAACF,IAAa,QAAQ,UAAU,YAAc,SAAUG,EAAS,CACjF,IAAIC,EACJ,OAAOD,GAAY,OAAuCC,EAAuBD,EAAQ,eAAiB,MAAQC,IAAyB,OAA3F,OAA6GA,EAAqB,KAAKD,CAAO,CAChM,EAAI,SAAUA,EAAS,CACrB,OAAOA,GAAY,KAA6B,OAASA,EAAQ,aACnE,EAUIE,EAAU,SAASA,EAAQC,EAAMC,EAAQ,CAC3C,IAAIC,EACAD,IAAW,SACbA,EAAS,IAKX,IAAIE,EAAWH,GAAS,OAAoCE,EAAqBF,EAAK,gBAAkB,MAAQE,IAAuB,OAArF,OAAuGA,EAAmB,KAAKF,EAAM,OAAO,EAC1LI,EAAQD,IAAa,IAAMA,IAAa,OAOxC3C,EAAS4C,GAASH,GAAUD,GAAQD,EAAQC,EAAK,UAAU,EAE/D,OAAOxC,CACT,EAsBI6C,GAAgB,SAAuBC,EAAIC,EAAkBC,EAAQ,CAGvE,GAAIT,EAAQO,CAAE,EACZ,MAAO,GAET,IAAIG,EAAa,MAAM,UAAU,MAAM,MAAMH,EAAG,iBAAiBb,CAAiB,CAAC,EACnF,OAAIc,GAAoBZ,EAAQ,KAAKW,EAAIb,CAAiB,GACxDgB,EAAW,QAAQH,CAAE,EAEvBG,EAAaA,EAAW,OAAOD,CAAM,EAC9BC,CACT,EAoCIC,GAA2B,SAASA,EAAyBC,EAAUJ,EAAkBK,EAAS,CAGpG,QAFIH,EAAa,CAAA,EACbI,EAAkB,MAAM,KAAKF,CAAQ,EAClCE,EAAgB,QAAQ,CAC7B,IAAIhB,EAAUgB,EAAgB,QAC9B,GAAI,CAAAd,EAAQF,EAAS,EAAK,EAK1B,GAAIA,EAAQ,UAAY,OAAQ,CAE9B,IAAIiB,EAAWjB,EAAQ,mBACnBkB,EAAUD,EAAS,OAASA,EAAWjB,EAAQ,SAC/CmB,EAAmBN,EAAyBK,EAAS,GAAMH,CAAO,EAClEA,EAAQ,QACVH,EAAW,KAAK,MAAMA,EAAYO,CAAgB,EAElDP,EAAW,KAAK,CACd,YAAaZ,EACb,WAAYmB,CACtB,CAAS,CAET,KAAW,CAEL,IAAIC,EAAiBtB,EAAQ,KAAKE,EAASJ,CAAiB,EACxDwB,GAAkBL,EAAQ,OAAOf,CAAO,IAAMU,GAAoB,CAACI,EAAS,SAASd,CAAO,IAC9FY,EAAW,KAAKZ,CAAO,EAIzB,IAAIqB,EAAarB,EAAQ,YAEzB,OAAOe,EAAQ,eAAkB,YAAcA,EAAQ,cAAcf,CAAO,EAKxEsB,EAAkB,CAACpB,EAAQmB,EAAY,EAAK,IAAM,CAACN,EAAQ,kBAAoBA,EAAQ,iBAAiBf,CAAO,GACnH,GAAIqB,GAAcC,EAAiB,CAOjC,IAAIC,EAAoBV,EAAyBQ,IAAe,GAAOrB,EAAQ,SAAWqB,EAAW,SAAU,GAAMN,CAAO,EACxHA,EAAQ,QACVH,EAAW,KAAK,MAAMA,EAAYW,CAAiB,EAEnDX,EAAW,KAAK,CACd,YAAaZ,EACb,WAAYuB,CACxB,CAAW,CAEX,MAGQP,EAAgB,QAAQ,MAAMA,EAAiBhB,EAAQ,QAAQ,CAElE,CACF,CACD,OAAOY,CACT,EAuDIY,GAAU,SAAiBrB,EAAM,CACnC,OAAOA,EAAK,UAAY,OAC1B,EACIsB,GAAgB,SAAuBtB,EAAM,CAC/C,OAAOqB,GAAQrB,CAAI,GAAKA,EAAK,OAAS,QACxC,EACIuB,GAAuB,SAA8BvB,EAAM,CAC7D,IAAI,EAAIA,EAAK,UAAY,WAAa,MAAM,UAAU,MAAM,MAAMA,EAAK,QAAQ,EAAE,KAAK,SAAUwB,EAAO,CACrG,OAAOA,EAAM,UAAY,SAC7B,CAAG,EACD,OAAO,CACT,EAuCIC,GAAiB,SAAwBzB,EAAM,CACjD,IAAI0B,EAwBAC,EAAW3B,GAAQJ,EAAYI,CAAI,EACnC4B,GAAgBF,EAAYC,KAAc,MAAQD,IAAc,OAAS,OAASA,EAAU,KAI5FG,EAAW,GACf,GAAIF,GAAYA,IAAa3B,EAAM,CACjC,IAAI8B,EAAeC,EAAuBC,EAE1C,IADAH,EAAW,CAAC,GAAGC,EAAgBF,KAAkB,MAAQE,IAAkB,SAAWC,EAAwBD,EAAc,iBAAmB,MAAQC,IAA0B,QAAUA,EAAsB,SAASH,CAAY,GAAK5B,GAAS,OAA4BgC,EAAsBhC,EAAK,iBAAmB,MAAQgC,IAAwB,QAAUA,EAAoB,SAAShC,CAAI,GAClY,CAAC6B,GAAYD,GAAc,CAChC,IAAIK,EAAYC,EAAgBC,EAIhCR,EAAW/B,EAAYgC,CAAY,EACnCA,GAAgBK,EAAaN,KAAc,MAAQM,IAAe,OAAS,OAASA,EAAW,KAC/FJ,EAAW,CAAC,GAAGK,EAAiBN,KAAkB,MAAQM,IAAmB,SAAWC,EAAwBD,EAAe,iBAAmB,MAAQC,IAA0B,QAAUA,EAAsB,SAASP,CAAY,EAC1O,CACF,CACD,OAAOC,CACT,EACIO,EAAa,SAAoBpC,EAAM,CACzC,IAAIqC,EAAwBrC,EAAK,sBAAuB,EACtDsC,EAAQD,EAAsB,MAC9BE,EAASF,EAAsB,OACjC,OAAOC,IAAU,GAAKC,IAAW,CACnC,EACIC,GAAW,SAAkBxC,EAAMyC,EAAM,CAC3C,IAAIC,EAAeD,EAAK,aACtBE,EAAgBF,EAAK,cAMvB,GAAI,iBAAiBzC,CAAI,EAAE,aAAe,SACxC,MAAO,GAET,IAAI4C,EAAkBjD,EAAQ,KAAKK,EAAM,+BAA+B,EACpE6C,EAAmBD,EAAkB5C,EAAK,cAAgBA,EAC9D,GAAIL,EAAQ,KAAKkD,EAAkB,uBAAuB,EACxD,MAAO,GAET,GAAI,CAACH,GAAgBA,IAAiB,QAAUA,IAAiB,cAAe,CAC9E,GAAI,OAAOC,GAAkB,WAAY,CAIvC,QADIG,EAAe9C,EACZA,GAAM,CACX,IAAI+C,EAAgB/C,EAAK,cACrBgD,EAAWpD,EAAYI,CAAI,EAC/B,GAAI+C,GAAiB,CAACA,EAAc,YAAcJ,EAAcI,CAAa,IAAM,GAIjF,OAAOX,EAAWpC,CAAI,EACbA,EAAK,aAEdA,EAAOA,EAAK,aACH,CAAC+C,GAAiBC,IAAahD,EAAK,cAE7CA,EAAOgD,EAAS,KAGhBhD,EAAO+C,CAEV,CACD/C,EAAO8C,CACR,CAWD,GAAIrB,GAAezB,CAAI,EAKrB,MAAO,CAACA,EAAK,eAAgB,EAAC,OAmBhC,GAAI0C,IAAiB,cACnB,MAAO,EAGb,SAAaA,IAAiB,gBAM1B,OAAON,EAAWpC,CAAI,EAKxB,MAAO,EACT,EAKIiD,GAAyB,SAAgCjD,EAAM,CACjE,GAAI,mCAAmC,KAAKA,EAAK,OAAO,EAGtD,QAFIkD,EAAalD,EAAK,cAEfkD,GAAY,CACjB,GAAIA,EAAW,UAAY,YAAcA,EAAW,SAAU,CAE5D,QAASC,EAAI,EAAGA,EAAID,EAAW,SAAS,OAAQC,IAAK,CACnD,IAAI3B,EAAQ0B,EAAW,SAAS,KAAKC,CAAC,EAEtC,GAAI3B,EAAM,UAAY,SAGpB,OAAO7B,EAAQ,KAAKuD,EAAY,sBAAsB,EAAI,GAAO,CAAC1B,EAAM,SAASxB,CAAI,CAExF,CAED,MAAO,EACR,CACDkD,EAAaA,EAAW,aACzB,CAKH,MAAO,EACT,EACIE,EAAkC,SAAyCxC,EAASZ,EAAM,CAC5F,MAAI,EAAAA,EAAK,UAITD,EAAQC,CAAI,GAAKsB,GAActB,CAAI,GAAKwC,GAASxC,EAAMY,CAAO,GAE9DW,GAAqBvB,CAAI,GAAKiD,GAAuBjD,CAAI,EAI3D,EA6DIqD,GAAY,SAAmBC,EAAW1C,EAAS,CACrDA,EAAUA,GAAW,GACrB,IAAIH,EACJ,OAAIG,EAAQ,cACVH,EAAaC,GAAyB,CAAC4C,CAAS,EAAG1C,EAAQ,iBAAkB,CAC3E,OAAQwC,EAAgC,KAAK,KAAMxC,CAAO,EAC1D,QAAS,GACT,cAAeA,EAAQ,aAC7B,CAAK,EAEDH,EAAaJ,GAAciD,EAAW1C,EAAQ,iBAAkBwC,EAAgC,KAAK,KAAMxC,CAAO,CAAC,EAE9GH,CACT,qVC1hBA8C,GAAA,CAAA,CAAA,UAAAC,EAAA,GAAAC,KAAA,CACE,MAAA7E,EAAA8E,SAAA,IAAA,EACAC,EAAAC,KAEAC,OAAAA,EAAAA,UAAA,IAAA,CACE,CAAAL,GAAAG,GACA/E,EAAA,QAAA,OAAkB,EAAA,CAAA,CAAA,EAGpBkF,EAAA,MAAA,CAAA,UAAAC,EAAA,UAAA,SAAAD,EAAA,QAAA,CAAA,IAAAlF,EAAA,UAAAmF,EAAA,MAAA,aAAA,MAAA,eAAA,MAAA,YAAA,MAAA,SAAA,MAAA,WAAA,QAAA,GAAAN,CAAA,CAAA,CAAA,CAAA,CAGF,uMCEA,MAAAO,GAAA,CAAA,CAAA,KAAAC,EAAA,UAAAC,EAAA,MAAAC,EAAA,WAAAC,EAAA,KAAAC,EAAA,OAAAC,EAAA,GAAA,QAAAC,EAAA,cAAAC,CAAA,IAAA,CACE,MAAAC,EAAAC,EAAAA,QAAA,IAAA,CACE,GAAA,CAAAN,EAAiB,OACjB,MAAAO,EAAA,IAAA,KAAA,mBAAA,KAAA,CAAA,QAAA,MAAA,CAAA,EACAC,EAAA,KAAA,IAAA,EAAAR,EACAS,EAAA,KAAA,MAAAD,EAAA,IAAA,EAAA,EACAE,EAAA,KAAA,MAAAD,EAAA,EAAA,EACAE,EAAA,KAAA,MAAAD,EAAA,EAAA,EAGA,OAAAC,EAAA,EAAcJ,EAAA,OAAA,CAAAI,EAAA,KAAA,EACdD,EAAA,EAAeH,EAAA,OAAA,CAAAG,EAAA,MAAA,EACfH,EAAA,OAAA,CAAAE,EAAA,QAAA,CAA0C,EAAA,CAAAT,CAAA,CAAA,EAE5CY,EAAAN,EAAAA,QAAA,IAAA,CACE,GAAAL,EACA,OAAAjI,GAAAiI,CAAA,CAAoB,EAAA,CAAAA,CAAA,CAAA,EAGtB,OAAAY,EAAA,MAAA,CAAA,UAAAC,EAAAnB,EAAA,WAAAG,EAAAH,EAAA,cAAA,MAAA,EAAA,SAAA,EAAA,QAAA,IAAAQ,GAAA,YAAAA,EAAAN,GAAA,UAAA3G,GAAA,EACEA,EAAA,OAAA,SAAAA,EAAA,OAAA,WACEA,EAAA,eAAA,EACAkH,GAAA,MAAAA,EAAAlH,EAAA,OAAA,QAAA,QAAA,SACF,EAAA,cAAA,IAAAkH,GAAA,YAAAA,EAAA,SAAA,SAAA,CAEAV,EAAA,MAAA,CAAA,UAAAC,EAAA,YAAA,IAAAlJ,GAAA,EAA8DoK,EAAA,MAAA,CAAA,UAAAlB,EAAA,WAAA,SAAA,CAE5DD,EAAA,MAAA,CAAA,UAAAC,EAAA,YAAA,MAAA,uBAAA,SAAAI,EAAA,EAAwEc,EAAA,MAAA,CAAA,UAAA,QAAA,SAAA,CAChDR,EAAA,IAAsBH,EAAA,MAAA,GAAA,CAAkB,EAAA,EAAER,EAAA,MAAA,CAAA,UAAA,QAAA,SAAAkB,EAAA,CAC5B,EAAA,CACxC,CAAA,CAAA,CAEJ,EAQAG,EAAA,CAAA,CAAA,UAAAC,EAAA,gBAAAC,EAAA,cAAAC,KAAA,CACE,MAAAC,EAAA7B,EAAAA,SACA8B,EAAA9B,SAAA,IAAA,EAEA+B,GAAA,OAAA,UAAAnI,GAAA,CACE,GAAAA,EAAA,OAAA,aAAAA,EAAA,OAAA,UAAA,CACEA,EAAA,eAAA,EACA,MAAAoI,EAAApI,EAAA,OAAA,YAAA,EAAA,GACAqD,EAAA0C,GAAAkC,EAAA,OAAA,EACAI,EAAAhF,EAAA,QAAA,SAAA,aAAA,EACA,GAAAgF,IAAA,GAA6B,OAC7B,MAAAC,EAAAjF,EAAAgF,EAAAD,CAAA,EACAE,GAAA,MAAAA,EAAA,OAAgB,CAClB,CAAA,EAGF,KAAA,CAAAC,EAAAC,CAAA,EAAAC,EAAA,SAAA,EAAA,EACA,CAAAC,EAAAC,CAAA,EAAAF,EAAA,SAAA,EAAA,EAEA,OAAAd,EAAA,MAAA,CAAA,IAAAM,EAAA,SAAA,CACEzB,EAAA,MAAA,CAAA,UAAA,SAAA,CAAA,EAAyBmB,EAAA,MAAA,CAAA,UAAAC,EAAA,aAAAnB,EAAA,IAAA,EAAA,SAAA,CAEvBkB,EAAA,MAAA,CAAA,MAAA,CAAA,QAAA,OAAA,cAAA,QAAA,EAAA,SAAA,CACEnB,EAAA,OAAA,CAAA,UAAAoB,EAAA,eAAAnB,EAAA,KAAA,EAAA,SAAA,qBAAA,EAA6ED,EAAAoC,GAAA,CAAA,UAAA,GAAA,MAAAL,EAAA,SAAA,CAAA,CAAA,OAAA,CAAA,MAAAlH,CAAA,CAAA,IAAAmH,EAAAnH,CAAA,EAAA,CACU,EAAA,EACzFmF,EAAA,MAAA,CAAA,UAAAC,EAAA,QAAA,SAAAqB,EAAA,OAAAe,GAAAA,EAAA,MAAA,cAAA,SAAAN,EAAA,YAAA,CAAA,CAAA,EAAA,IAAA,CAAA,CAAA,KAAA5B,EAAA,MAAAE,EAAA,KAAAE,EAAA,WAAAD,EAAA,OAAAE,CAAA,IAAAR,EAAAE,GAAA,CAAA,MAAAG,EAAA,WAAAC,EAAA,KAAAC,EAAA,KAAAJ,EAAA,QAAAgC,EAAA,UAAAD,IAAA/B,EAAA,cAAAmC,GAAA,OAKQA,IAAA,QAA6Bd,EAAA,OAAArB,CAAA,EAA0BmC,IAAA,WACrBC,EAAAb,EAAA,UAAA,MAAAa,EAAA,QAA2B,EAAA,OAAA/B,CAAA,EAAAL,CAAA,CAAA,EAAA,EAIrEgB,EAAA,MAAA,CAAA,MAAA,CAAA,QAAA,OAAA,cAAA,SAAA,SAAA,GAAA,EAAA,SAAA,CAEEA,EAAA,MAAA,CAAA,SAAA,CACEnB,EAAAwC,EAAA,CAAA,QAAAd,EAAA,SAAA,CAAAQ,EAAA,QAAA,IAAAV,EAAA,OAAAU,CAAA,EAAA,SAAA,YAAA,CAAA,EAAqHlC,EAAAwC,EAAA,CAAA,QAAA,IAAAjB,EAAA,QAAA,EAAA,SAAA,mBAAA,CACnD,EAAA,EACpEJ,EAAA,MAAA,CAAA,SAAA,CAEEnB,EAAAwC,EAAA,CAAA,MAAA,CAAA,MAAA,GAAA,EAAA,SAAA,CAAAN,EAAA,QAAA,IAAAV,EAAA,SAAAU,CAAA,EAAA,SAAA,SAAA,EAAoHlC,EAAAwC,EAAA,CAAA,MAAA,CAAA,MAAA,GAAA,EAAA,SAAA,CAAAN,EAAA,QAAA,IAAAV,EAAA,SAAAU,CAAA,EAAA,SAAA,SAAA,EACAlC,EAAAwC,EAAA,CAAA,MAAA,CAAA,MAAA,GAAA,EAAA,QAAA,IAAAhB,EAAA,OAAAU,CAAA,EAAA,SAAA,GAAA,SAAA,OAAA,EACYlC,EAAAwC,EAAA,CAAA,MAAA,CAAA,MAAA,GAAA,EAAA,QAAA,IAAAjB,EAAA,QAAA,EAAA,SAAA,QAAA,CAAA,CACjD,EAAA,CACjF,EAAA,CACF,EAAA,CACF,CAAA,CAAA,CAEJ;;","x_google_ignoreList":[0,1,2,3,4,5]}